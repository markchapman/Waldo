.text:0000000000000000 ;
.text:0000000000000000 ; +-------------------------------------------------------------------------+
.text:0000000000000000 ; |   This file has been	generated by The Interactive Disassembler (IDA)	   |
.text:0000000000000000 ; |	  Copyright (c)	2009 by	Hex-Rays, <support@hex-rays.com>	   |
.text:0000000000000000 ; |			License	info: 48-313D-7374-F1			   |
.text:0000000000000000 ; |   Aditya Thakur, University of Wisconsin/Computer Sciences Department   |
.text:0000000000000000 ; +-------------------------------------------------------------------------+
.text:0000000000000000 ;
.text:0000000000000000 ; Input MD5   : B2B0B21556DB37EF37566C9BD19D5DC2
.text:0000000000000000
.text:0000000000000000 ; File Name   : C:\aditya\work\waldo\tests\abl-1.2\test\test1.o
.text:0000000000000000 ; Format	     : ELF (Relocatable)
.text:0000000000000000 ;
.text:0000000000000000 ; Source	File : 'test1.c'
.text:0000000000000000
.text:0000000000000000		       .686p
.text:0000000000000000		       .mmx
.text:0000000000000000		       .model flat
.text:0000000000000000 .intel_syntax noprefix
.text:0000000000000000
.text:0000000000000000 ; ===========================================================================
.text:0000000000000000
.text:0000000000000000 ; Segment type: Pure code
.text:0000000000000000 ; Segment permissions: Read/Execute
.text:0000000000000000 _text	       segment para public 'CODE' use64
.text:0000000000000000		       assume cs:_text
.text:0000000000000000		       assume es:nothing, ss:nothing, ds:_text,	fs:nothing, gs:nothing
.text:0000000000000000
.text:0000000000000000 ; =============== S U B R O U T I N E =======================================
.text:0000000000000000
.text:0000000000000000
.text:0000000000000000		       public main
.text:0000000000000000 main	       proc near	       ; DATA XREF: .eh_frame:00000000000000E8o
.text:0000000000000000
.text:0000000000000000 var_1C	       = dword ptr -1Ch
.text:0000000000000000
.text:0000000000000000		       push    r12
.text:0000000000000002		       xor     r12d, r12d
.text:0000000000000005		       push    rbp
.text:0000000000000006		       xor     ebp, ebp
.text:0000000000000008		       push    rbx
.text:0000000000000009		       xor     ebx, ebx
.text:000000000000000B		       sub     rsp, 10h
.text:000000000000000F		       mov     [rsp+28h+var_1C], 0
.text:0000000000000017		       jmp     short loc_30
.text:0000000000000017 ; ---------------------------------------------------------------------------
.text:0000000000000019		       align 20h
.text:0000000000000020
.text:0000000000000020 loc_20:				       ; CODE XREF: main+40j
.text:0000000000000020					       ; main+56j
.text:0000000000000020		       mov     eax, [rsp+28h+var_1C]
.text:0000000000000024		       add     eax, 1
.text:0000000000000027		       cmp     eax, 4
.text:000000000000002A		       mov     [rsp+28h+var_1C], eax
.text:000000000000002E		       jg      short loc_6B
.text:0000000000000030
.text:0000000000000030 loc_30:				       ; CODE XREF: main+17j
.text:0000000000000030					       ; main+69j
.text:0000000000000030		       mov     edi, 10h	       ; size
.text:0000000000000035		       call    malloc
.text:000000000000003A		       test    rax, rax
.text:000000000000003D		       mov     rdx, rax
.text:0000000000000040		       jz      short loc_20
.text:0000000000000042		       mov     eax, [rsp+28h+var_1C]
.text:0000000000000046		       add     r12, 1
.text:000000000000004A		       test    rbx, rbx
.text:000000000000004D		       mov     [rdx+8],	rbp
.text:0000000000000051		       mov     rbp, rdx
.text:0000000000000054		       mov     [rdx], eax
.text:0000000000000056		       jnz     short loc_20
.text:0000000000000058		       mov     eax, [rsp+28h+var_1C]
.text:000000000000005C		       mov     rbx, rdx
.text:000000000000005F		       add     eax, 1
.text:0000000000000062		       cmp     eax, 4
.text:0000000000000065		       mov     [rsp+28h+var_1C], eax
.text:0000000000000069		       jle     short loc_30
.text:000000000000006B
.text:000000000000006B loc_6B:				       ; CODE XREF: main+2Ej
.text:000000000000006B		       mov     rbx, rbp
.text:000000000000006E		       jmp     short loc_82
.text:0000000000000070 ; ---------------------------------------------------------------------------
.text:0000000000000070
.text:0000000000000070 loc_70:				       ; CODE XREF: main+85j
.text:0000000000000070		       mov     esi, [rbx]
.text:0000000000000072		       mov     edi, offset format ; "%d\n"
.text:0000000000000077		       xor     eax, eax
.text:0000000000000079		       call    printf
.text:000000000000007E		       mov     rbx, [rbx+8]
.text:0000000000000082
.text:0000000000000082 loc_82:				       ; CODE XREF: main+6Ej
.text:0000000000000082		       test    rbx, rbx
.text:0000000000000085		       jnz     short loc_70
.text:0000000000000087		       sub     r12, 1
.text:000000000000008B		       cmp     r12, 0FFFFFFFFFFFFFFFFh
.text:000000000000008F		       jz      short loc_AA
.text:0000000000000091
.text:0000000000000091 loc_91:				       ; CODE XREF: main+A8j
.text:0000000000000091		       mov     rbx, [rbp+8]
.text:0000000000000095		       mov     rdi, rbp	       ; ptr
.text:0000000000000098		       sub     r12, 1
.text:000000000000009C		       call    free
.text:00000000000000A1		       cmp     r12, 0FFFFFFFFFFFFFFFFh
.text:00000000000000A5		       mov     rbp, rbx
.text:00000000000000A8		       jnz     short loc_91
.text:00000000000000AA
.text:00000000000000AA loc_AA:				       ; CODE XREF: main+8Fj
.text:00000000000000AA		       add     rsp, 10h
.text:00000000000000AE		       xor     eax, eax
.text:00000000000000B0		       pop     rbx
.text:00000000000000B1		       pop     rbp
.text:00000000000000B2		       pop     r12
.text:00000000000000B4		       retn
.text:00000000000000B4 main	       endp
.text:00000000000000B4
.text:00000000000000B4 _text	       ends
.text:00000000000000B4
.data:00000000000000B8 ; ===========================================================================
.data:00000000000000B8
.data:00000000000000B8 ; Segment type: Zero-length
.data:00000000000000B8 ; Segment permissions: Read/Write
.data:00000000000000B8 _data	       segment dword public 'DATA' use64
.data:00000000000000B8 _data	       ends
.data:00000000000000B8
.bss:00000000000000BC ;	===========================================================================
.bss:00000000000000BC
.bss:00000000000000BC ;	Segment	type: Zero-length
.bss:00000000000000BC ;	Segment	permissions: Read/Write
.bss:00000000000000BC _bss	      segment dword public 'BSS' use64
.bss:00000000000000BC _bss	      ends
.bss:00000000000000BC
.rodata.str1.1:00000000000000BD	; ===========================================================================
.rodata.str1.1:00000000000000BD
.rodata.str1.1:00000000000000BD	; Segment type:	Pure data
.rodata.str1.1:00000000000000BD	; Segment permissions: Read
.rodata.str1.1:00000000000000BD	_rodata_str1_1	segment	byte public 'CONST' use64
.rodata.str1.1:00000000000000BD			assume cs:_rodata_str1_1
.rodata.str1.1:00000000000000BD			;org 0BDh
.rodata.str1.1:00000000000000BD	; char format[4]
.rodata.str1.1:00000000000000BD	format		db '%d',0Ah,0           ; DATA XREF: main+72o
.rodata.str1.1:00000000000000BD	_rodata_str1_1	ends
.rodata.str1.1:00000000000000BD
.eh_frame:00000000000000C8 ; ===========================================================================
.eh_frame:00000000000000C8
.eh_frame:00000000000000C8 ; Segment type: Pure	data
.eh_frame:00000000000000C8 ; Segment permissions: Read
.eh_frame:00000000000000C8 ; Segment alignment 'qword' can not be represented in assembly
.eh_frame:00000000000000C8 _eh_frame	   segment para	public 'CONST' use64
.eh_frame:00000000000000C8		   assume cs:_eh_frame
.eh_frame:00000000000000C8		   ;org	0C8h
.eh_frame:00000000000000C8		   dq 14h, 110780100527A01h, 19008070C03h, 1C00000024h
.eh_frame:00000000000000E8		   dd offset main
.eh_frame:00000000000000EC		   dd 0B5h
.eh_frame:00000000000000F0		   dq 0E44028C100E4200h, 483200E43038618h, 300E46h
.eh_frame:00000000000000F0 _eh_frame	   ends
.eh_frame:00000000000000F0
extern:0000000000000108	; ===========================================================================
extern:0000000000000108
extern:0000000000000108	; Segment type:	Externs
extern:0000000000000108	; extern
extern:0000000000000108	; void *malloc(size_t size)
extern:0000000000000108			extrn malloc:near	; CODE XREF: main+35p
extern:000000000000010C	; int printf(const char	*format, ...)
extern:000000000000010C			extrn printf:near	; CODE XREF: main+79p
extern:0000000000000110	; void free(void *ptr)
extern:0000000000000110			extrn free:near		; CODE XREF: main+9Cp
extern:0000000000000110
extern:0000000000000110
extern:0000000000000110			end
